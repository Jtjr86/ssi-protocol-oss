# B2.2 Pre-Flight Checklist (Review BEFORE Accepting Copilot Code)

**Use this checklist to validate Copilot's generated JWT auth code before applying.**

---

## ğŸ” Guardrail 1: JWT Secret from Environment Variable

**Check `src/auth/jwtAuth.ts`:**

- [ ] âœ… JWT_SECRET loaded from `process.env.JWT_SECRET`
- [ ] âœ… Clear error message if JWT_SECRET is missing
- [ ] âœ… No hardcoded secrets in code

**Example GOOD pattern:**
```typescript
const JWT_SECRET = process.env.JWT_SECRET;
if (!JWT_SECRET) {
  throw new Error('JWT_SECRET environment variable is required');
}

// Later in middleware:
const payload = jwt.verify(token, JWT_SECRET) as JwtPayload;
```

**Example BAD pattern:**
```typescript
// âŒ REJECT - hardcoded secret
const payload = jwt.verify(token, 'hardcoded-secret-123');
```

---

## âš¡ Guardrail 2: JWT Verification with Proper Error Handling

**Check `src/auth/jwtAuth.ts`:**

- [ ] âœ… Uses `jsonwebtoken.verify()` (not `decode()` which doesn't validate)
- [ ] âœ… Catches `TokenExpiredError` â†’ returns 401 TOKEN_EXPIRED
- [ ] âœ… Catches `JsonWebTokenError` â†’ returns 401 INVALID_TOKEN
- [ ] âœ… Catches generic errors â†’ returns 401 MALFORMED_TOKEN
- [ ] âœ… If no Authorization header â†’ calls `next()` (falls through to API key)

**Example GOOD pattern:**
```typescript
try {
  const payload = jwt.verify(token, JWT_SECRET) as JwtPayload;
  (req as any).auth = {
    tenant_id: payload.tenant_id,
    role: payload.role,
    auth_method: 'jwt',
    sub: payload.sub,
  };
  return next();
} catch (error) {
  if (error instanceof jwt.TokenExpiredError) {
    return res.status(401).json({ error: 'TOKEN_EXPIRED' });
  }
  if (error instanceof jwt.JsonWebTokenError) {
    return res.status(401).json({ error: 'INVALID_TOKEN' });
  }
  return res.status(401).json({ error: 'MALFORMED_TOKEN' });
}
```

**Example BAD pattern:**
```typescript
// âŒ REJECT - uses decode() which doesn't validate signature
const payload = jwt.decode(token) as JwtPayload;
```

---

## ğŸ”— Guardrail 3: Middleware Precedence (JWT Before API Key)

**Check `src/server.ts`:**

- [ ] âœ… JWT middleware applied BEFORE API key middleware
- [ ] âœ… Both middlewares call `next()` if their auth method is absent
- [ ] âœ… Tenant extraction middleware (already exists) uses `req.auth` from either source

**Example GOOD pattern:**
```typescript
app.use(jwtAuthMiddleware);      // Try JWT first
app.use(apiKeyAuthMiddleware);   // Fall back to API key if no JWT

// Existing tenant extraction middleware (no changes needed):
app.use((req, res, next) => {
  const auth = (req as any).auth as AuthContext | undefined;
  if (auth) {
    (req as any).tenant_id = auth.tenant_id;
  } else {
    (req as any).tenant_id = (req.headers['x-tenant-id'] as string) || 'default';
  }
  next();
});
```

**Example BAD pattern:**
```typescript
// âŒ REJECT - wrong order (API key before JWT)
app.use(apiKeyAuthMiddleware);
app.use(jwtAuthMiddleware);
```

---

## ğŸ§ª Guardrail 4: JWT Payload Validation

**Check `src/auth/jwtAuth.ts`:**

- [ ] âœ… Validates required fields: `tenant_id`, `role`, `sub`
- [ ] âœ… Returns 401 if required fields missing
- [ ] âœ… Role value validated against allowed roles (viewer, auditor, admin)

**Example GOOD pattern:**
```typescript
const payload = jwt.verify(token, JWT_SECRET) as JwtPayload;

if (!payload.tenant_id || !payload.role || !payload.sub) {
  return res.status(401).json({ error: 'INVALID_TOKEN_CLAIMS' });
}

const allowedRoles = ['viewer', 'auditor', 'admin'];
if (!allowedRoles.includes(payload.role)) {
  return res.status(401).json({ error: 'INVALID_ROLE' });
}
```

**Example BAD pattern:**
```typescript
// âŒ REJECT - no validation of required fields
const payload = jwt.verify(token, JWT_SECRET) as JwtPayload;
(req as any).auth = payload;  // Blindly trust payload
```

---

## ğŸ”’ Guardrail 5: Test Suite Uses Real JWT Generation

**Check `scripts/jwt_auth_test.ts`:**

- [ ] âœ… Generates real JWTs using `jsonwebtoken.sign()`
- [ ] âœ… Test 1: Valid JWT with future expiry (now + 1 hour)
- [ ] âœ… Test 2: Expired JWT with past expiry (now - 1 hour)
- [ ] âœ… Test 3: Invalid signature (wrong secret)
- [ ] âœ… Test 4: API key fallback works (no JWT header)
- [ ] âœ… Test 5: JWT tenant overrides x-tenant-id header

**Example GOOD pattern:**
```typescript
import jwt from 'jsonwebtoken';

const JWT_SECRET = process.env.JWT_SECRET || 'dev_secret_key_256_bit_minimum_length_required_here_1234567890';

// Test 1: Valid JWT
const validToken = jwt.sign(
  { sub: 'user-1', tenant_id: 'tenant-alpha', role: 'auditor' },
  JWT_SECRET,
  { expiresIn: '1h' }
);

// Test 2: Expired JWT
const expiredToken = jwt.sign(
  { sub: 'user-2', tenant_id: 'tenant-alpha', role: 'auditor' },
  JWT_SECRET,
  { expiresIn: '-1h' }  // Already expired
);
```

---

## âŒ Reject Criteria (Do NOT Accept Code If Any Apply)

- [ ] âŒ JWT secret hardcoded in source code
- [ ] âŒ Uses `jwt.decode()` instead of `jwt.verify()`
- [ ] âŒ JWT middleware applied AFTER API key middleware
- [ ] âŒ No error handling for TokenExpiredError
- [ ] âŒ No validation of required JWT claims (tenant_id, role, sub)
- [ ] âŒ Test suite uses mock/fake JWTs instead of real jwt.sign()
- [ ] âŒ Modifies protocol kernel or Track A+ endpoints
- [ ] âŒ Creates user management endpoints (out of scope for B2.2)

---

## âœ… Final Validation Checklist

Before accepting Copilot's code:

1. [ ] JWT_SECRET from environment variable (Guardrail 1)
2. [ ] jwt.verify() with proper error handling (Guardrail 2)
3. [ ] JWT middleware before API key middleware (Guardrail 3)
4. [ ] Required JWT claims validated (Guardrail 4)
5. [ ] Test suite uses real JWT generation (Guardrail 5)
6. [ ] No reject criteria apply
7. [ ] Code matches existing style (apiKeyAuth.ts, server.ts)
8. [ ] AuthContext interface reused (no duplicate types)

---

**If all checks pass:** Accept code, proceed to execution.  
**If any check fails:** Reject, clarify constraint, request regeneration.
