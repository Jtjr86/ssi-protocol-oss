# Track B2.3: RBAC Middleware - Pre-Flight Checklist

**Before generating any code, verify these 5 guardrails are enforced.**

---

## Guardrail 1: Dev Mode Bypass ONLY for ENABLE_INSECURE_DEV

### ✅ GOOD (safe dev bypass)
```typescript
export function requireAuth(req: Request, res: Response, next: NextFunction): void {
  const auth = (req as any).auth as AuthContext | undefined;
  
  // Check if authenticated (JWT or API key set req.auth)
  if (!auth) {
    // Dev mode bypass: allow unauthenticated requests ONLY if env var is 'true'
    if (process.env.ENABLE_INSECURE_DEV === 'true') {
      console.log('[RBAC] Dev mode: allowing unauthenticated request');
      return next();
    }
    
    // Production: require authentication
    return res.status(403).json({ error: 'AUTHENTICATION_REQUIRED' });
  }
  
  // Authenticated: proceed
  next();
}
```

### ❌ BAD (unsafe bypass)
```typescript
// BAD: Checks for any truthy value (dangerous)
if (process.env.ENABLE_INSECURE_DEV) { /* bypass */ }

// BAD: No dev mode bypass (breaks backwards compat)
if (!auth) {
  return res.status(403).json({ error: 'AUTHENTICATION_REQUIRED' });
}

// BAD: Hardcoded bypass (never acceptable)
const DEV_MODE = true;
if (!auth && DEV_MODE) { /* bypass */ }
```

**Why it matters:** Dev mode bypass is critical for testing, but must be explicitly opt-in with exact string match.

---

## Guardrail 2: Role Check AFTER Auth Check

### ✅ GOOD (safe order)
```typescript
// In server.ts
app.post("/v1/decisions", 
  requireAuth,           // 1. Check authentication first
  requireRole(['admin']), // 2. Then check role
  async (req, res) => { /* handler */ }
);
```

### ❌ BAD (unsafe order)
```typescript
// BAD: Role check before auth check (req.auth might be undefined)
app.post("/v1/decisions",
  requireRole(['admin']), // WRONG: auth might not exist yet
  requireAuth,
  async (req, res) => { /* handler */ }
);

// BAD: Role check without auth check
app.post("/v1/decisions",
  requireRole(['admin']), // WRONG: no auth check at all
  async (req, res) => { /* handler */ }
);
```

**Why it matters:** `requireRole` assumes `req.auth` exists. Must check auth first or it will crash.

---

## Guardrail 3: Explicit Role Lists (No Wildcards)

### ✅ GOOD (explicit allow list)
```typescript
// Explicit list of allowed roles
requireRole(['viewer', 'auditor', 'admin'])

// Single role (still explicit)
requireRole(['admin'])

// Two roles (clear intent)
requireRole(['auditor', 'admin'])
```

### ❌ BAD (wildcards or implicit allow)
```typescript
// BAD: Wildcard (too permissive)
requireRole(['*'])

// BAD: Empty array (allows all roles?)
requireRole([])

// BAD: Checking for "not viewer" instead of explicit allow
if (role !== 'viewer') { /* allow */ }
```

**Why it matters:** Security requires explicit allow lists. Wildcards or negation logic is error-prone.

---

## Guardrail 4: 403 for Insufficient Permissions (Not 401)

### ✅ GOOD (correct HTTP status codes)
```typescript
// No credentials or invalid credentials → 401
if (!auth) {
  return res.status(401).json({ error: 'AUTHENTICATION_REQUIRED' });
}

// Valid credentials, wrong role → 403
if (!allowedRoles.includes(auth.role)) {
  return res.status(403).json({ 
    error: 'INSUFFICIENT_PERMISSIONS',
    required_roles: allowedRoles,
    user_role: auth.role
  });
}
```

### ❌ BAD (wrong status codes)
```typescript
// BAD: Using 401 for role check (should be 403)
if (!allowedRoles.includes(auth.role)) {
  return res.status(401).json({ error: 'UNAUTHORIZED' });
}

// BAD: Using 403 for missing auth (should be 401)
if (!auth) {
  return res.status(403).json({ error: 'FORBIDDEN' });
}

// BAD: Using 500 for role check (not a server error)
if (!allowedRoles.includes(auth.role)) {
  return res.status(500).json({ error: 'INTERNAL_ERROR' });
}
```

**Why it matters:** 
- `401 UNAUTHORIZED` = "who are you?" (authentication failure)
- `403 FORBIDDEN` = "I know who you are, but you can't do this" (authorization failure)

---

## Guardrail 5: Test Suite Uses Real JWT/API Keys (No Mocks)

### ✅ GOOD (real credentials)
```typescript
import jwt from 'jsonwebtoken';

// Generate real JWT with viewer role
const viewerToken = jwt.sign(
  { sub: 'user-1', tenant_id: 'tenant-alpha', role: 'viewer' },
  JWT_SECRET,
  { expiresIn: '1h' }
);

// Use real seeded API key
const headers = {
  'x-api-key': 'ssi_test_auditor_key_alpha_2024' // From 003a_seed_dev_api_keys.sql
};

// Make actual HTTP request
const res = await fetch(`${GATEWAY_URL}/v1/decisions`, {
  method: 'POST',
  headers: { 'Authorization': `Bearer ${viewerToken}` },
  body: JSON.stringify({ /* ... */ })
});
```

### ❌ BAD (mocked credentials)
```typescript
// BAD: Mocking req.auth directly (bypasses middleware)
const mockReq = {
  auth: { tenant_id: 'tenant-alpha', role: 'viewer', auth_method: 'jwt' }
};

// BAD: Stubbing jwt.verify (doesn't test real verification)
sinon.stub(jwt, 'verify').returns({ role: 'viewer' });

// BAD: Using fake API keys not in database
const headers = { 'x-api-key': 'fake_key_123' };
```

**Why it matters:** Tests must exercise the full middleware stack (JWT verification, API key lookup, role extraction).

---

## Pre-Flight Validation Checklist

Before implementing B2.3, confirm:

- [ ] **Guardrail 1:** `requireAuth` checks `ENABLE_INSECURE_DEV === 'true'` (exact match)
- [ ] **Guardrail 2:** `requireAuth` is called BEFORE `requireRole` in route definitions
- [ ] **Guardrail 3:** All `requireRole` calls use explicit arrays (e.g., `['admin']`, `['viewer', 'auditor']`)
- [ ] **Guardrail 4:** Auth failures return `401`, role failures return `403`
- [ ] **Guardrail 5:** Test suite uses `jwt.sign()` and seeded API keys (no mocks)

---

## Reject Criteria (do NOT proceed if any are true)

❌ **Reject if:**
- `requireRole` is called without `requireAuth` on the same route
- Dev mode bypass uses any check other than `=== 'true'`
- Any route uses wildcard roles (`'*'`) or empty role arrays (`[]`)
- Role check returns `401` instead of `403`
- Test suite mocks `req.auth` instead of generating real JWTs/API keys

---

## Success Criteria (proceed to commit when all are true)

✅ **Proceed if:**
- `rbac_test.ts` exits 0 (all 6 tests pass)
- `jwt_auth_test.ts` exits 0 (no regression)
- `auth_api_key_test.ts` exits 0 (no regression)
- `tenant_isolation_test.ts` exits 0 (no regression)
- All 5 guardrails enforced in code
- Commit message includes test evidence + guardrails confirmation
