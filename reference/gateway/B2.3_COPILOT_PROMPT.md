# Track B2.3: RBAC Middleware (Role-Based Access Control)

**Goal:** Enforce role-based permissions on protected endpoints using the `role` field already attached by JWT/API key auth.

---

## 1. Create `src/auth/rbac.ts` - RBAC Middleware

### Role Definitions (from B2.1/B2.2)
- **viewer**: Read-only audit access (lowest privilege)
- **auditor**: Read-only + chain verification (medium privilege)
- **admin**: Write decisions + full audit access (highest privilege)

### Middleware Functions

#### `requireAuth(req, res, next)`
- Check if `req.auth` exists (set by JWT or API key middleware)
- If missing AND `ENABLE_INSECURE_DEV !== 'true'`: return `403 FORBIDDEN` with `{ error: 'AUTHENTICATION_REQUIRED' }`
- If missing AND `ENABLE_INSECURE_DEV === 'true'`: allow through (dev bypass)
- If present: call `next()`

#### `requireRole(allowedRoles: string[])`
Returns middleware that:
- Assumes `req.auth` exists (call `requireAuth` first)
- Check if `req.auth.role` is in `allowedRoles` array
- If not: return `403 FORBIDDEN` with `{ error: 'INSUFFICIENT_PERMISSIONS', required_roles: allowedRoles, user_role: req.auth.role }`
- If yes: call `next()`

---

## 2. Update `src/server.ts` - Apply RBAC to Protected Endpoints

### Protect POST /v1/decisions (admin only)
```typescript
import { requireAuth, requireRole } from "./auth/rbac";

app.post("/v1/decisions", requireAuth, requireRole(['admin']), async (req, res) => {
  // Existing decision logic...
});
```

### Protect GET /v1/audit/verify-chain/:rpx_id (auditor or admin)
```typescript
app.get("/v1/audit/verify-chain/:rpx_id", requireAuth, requireRole(['auditor', 'admin']), async (req, res) => {
  // Existing chain verification logic...
});
```

### Protect GET /v1/audit/verify/:rpx_id (viewer, auditor, or admin)
```typescript
app.get("/v1/audit/verify/:rpx_id", requireAuth, requireRole(['viewer', 'auditor', 'admin']), async (req, res) => {
  // Existing signature verification logic...
});
```

**Note:** If endpoint was previously unprotected, this is a **breaking change** (except for `ENABLE_INSECURE_DEV=true` bypass).

---

## 3. Create `scripts/rbac_test.ts` - RBAC Test Suite

### Test 1: Viewer cannot POST /v1/decisions (403)
- Create JWT with `role: 'viewer'`
- POST /v1/decisions with `Authorization: Bearer <token>`
- Expect: `403 FORBIDDEN`, `{ error: 'INSUFFICIENT_PERMISSIONS' }`

### Test 2: Admin can POST /v1/decisions (200)
- Create JWT with `role: 'admin'`
- POST /v1/decisions with `Authorization: Bearer <token>`
- Expect: `200 OK` with decision response

### Test 3: Viewer can GET /v1/audit/verify (200)
- Create JWT with `role: 'viewer'`
- GET /v1/audit/verify/:rpx_id (use existing RPX ID from Test 2)
- Expect: `200 OK` with signature verification result

### Test 4: Viewer cannot GET /v1/audit/verify-chain (403)
- Create JWT with `role: 'viewer'`
- GET /v1/audit/verify-chain/:rpx_id
- Expect: `403 FORBIDDEN`, `{ error: 'INSUFFICIENT_PERMISSIONS' }`

### Test 5: Auditor can GET /v1/audit/verify-chain (200)
- Create JWT with `role: 'auditor'`
- GET /v1/audit/verify-chain/:rpx_id (use RPX ID from Test 2)
- Expect: `200 OK` with chain verification result (anchored or break detected)

### Test 6: Dev mode bypass (unauthenticated write allowed)
- Set `ENABLE_INSECURE_DEV=true` in test environment
- POST /v1/decisions with NO `Authorization` header and NO `x-api-key`
- Expect: `200 OK` (dev bypass works, backwards compat)

---

## Expected Outcomes (Evidence for Claim Gates)

### ✅ Exit Criteria (must be EXIT 0)
1. `rbac_test.ts` - **EXIT 0** (all 6 tests pass)
2. `jwt_auth_test.ts` - **EXIT 0** (no regression from B2.2)
3. `auth_api_key_test.ts` - **EXIT 0** (no regression from B2.1)
4. `tenant_isolation_test.ts` - **EXIT 0** (no regression from B1)

### ✅ Safe Claims to Unlock
- "Role-based access control with tenant-scoped permissions"
- "Least-privilege enforcement (viewer < auditor < admin)"
- "Protected audit endpoints (verify-chain requires auditor+)"
- "Admin-only decision writes (unless dev mode enabled)"

### ❌ NOT Safe to Claim
- "Dynamic role assignment" (roles are in JWT/API key, not managed by Gateway)
- "Role hierarchy inheritance" (no nested roles, just flat list)
- "Per-tenant role customization" (roles are global, not tenant-scoped)

---

## Guardrails (enforce these in code + tests)

### Guardrail 1: Dev mode bypass ONLY for ENABLE_INSECURE_DEV
- `requireAuth` checks `process.env.ENABLE_INSECURE_DEV === 'true'`
- If true: allow unauthenticated requests (backwards compat)
- If false or unset: enforce authentication

### Guardrail 2: Role check AFTER auth check
- Always call `requireAuth` BEFORE `requireRole`
- If `req.auth` is missing, `requireRole` should throw error (safe-fail)

### Guardrail 3: Explicit role lists (no wildcards)
- `requireRole(['admin'])` not `requireRole('*')`
- Forces explicit declaration of allowed roles per endpoint

### Guardrail 4: 403 for insufficient permissions (not 401)
- `401 UNAUTHORIZED` = no credentials or bad credentials
- `403 FORBIDDEN` = valid credentials, insufficient permissions
- Use correct HTTP status codes

### Guardrail 5: Test suite uses real JWT/API key (no mocks)
- Tests generate actual JWTs with `jwt.sign()`
- Tests use actual seeded API keys from `003a_seed_dev_api_keys.sql`
- No mocking of `req.auth` (test the full middleware stack)

---

## Files to Create/Modify

### Create:
- `src/auth/rbac.ts` (RBAC middleware functions)
- `scripts/rbac_test.ts` (6 RBAC tests)

### Modify:
- `src/server.ts` (apply `requireAuth` + `requireRole` to protected endpoints)

### No Changes:
- Database schema (no new tables, roles come from JWT/API key)
- JWT/API key middleware (already attach `role` to `req.auth`)

---

## Success Criteria

**B2.3 is DONE when:**
1. ✅ All 6 RBAC tests pass (`rbac_test.ts` EXIT 0)
2. ✅ No regression in B2.2/B2.1/B1 tests (all EXIT 0)
3. ✅ Committed with evidence message + test results
4. ✅ Pushed to origin
5. ✅ `CLAIM_GATES_TRACK_B.md` updated with B2.3 evidence
